# 简要说明

## 注意

在发出请求之前需要进行persist stat，如果状态由变化的话

## 逻辑处理架构

raft维护raft的节点相关状态
raft handler 处理所有事件（外部请求，超时等等），修改raft 状态，返回/发出对应请求
raft handler own raft
raft handler 通过一个chan接受外部事件，同时实现对raft状态修改的串行化
事件处理流程是raft handler 的main函数,raft算法基本都通过这个事件触发的处理函数体现

**重要**
事件处理的流程的框架
根据role和event,派发相应的处理流程
处理流程的通用框架
validate event,修改状态，状态pesister,发送消息给其他节点/回复
可以根据这个框架来写单测,即输入事件，role，状态，检查状态变化，发送的消息

## 状态变化checklist

|election 超时|heartbeat timeout|append|append apply|vote|vote apply|

## 单元测试

### 选举

#### candidates

[x]超时开始选举
[x]选举失败，没有达到半数，继续下一轮
[x]选举失败，其他节点成功
[x]选举成功，发送心跳
[] followe/leader 接受选举
[] followe/leader 拒绝选举 已经投票/term  不对/logs不够新

#### following and leader

[]接受term
[]拒绝，term不符合
[]拒绝，已经vote给其他节点

### append

[x]正常append leader,follower
[x]append 截断 follower
[x]失败，term不符合当前
[x]拒绝，prex不符合 leader,follower

[x]leader 超时心跳发送
[x] append client 请求成功

[x]append reply 成功leader 更新commit,match_index,next_index

##

## 定时器

## election timeout 定时器

使用一个线程，sleep到[election_timeout_check] 时间点，发送超时事件给main,这个事件包含timeout check 时间点的数值
handler开始后需要初始化这个定时线程
timeout check时间点的设定：接受到外部有效信息（vote,append)后，说明当前有leader或者candidate存活，更新这个时间点，设置为now+rand(150-300ms)
当接收到timeout 事件，检查事件记录的timeout 时间点的数值是否等于当前的timeout check
如果是，说明没有接收到其他节点发来的有效信息，需要进行vote
如果不是，说明不需要vote，启动一个新的定时线程，重复sleep 到timeout check时间点

## leader heartbeat 定时器

heartbeat 时间，论文没找到，[election_timeout] 最小为150，network的delay最多是27,heartbeat使用20吧,这样在[election_timeout]之前可以发送3次

使用一个线程,每隔20ms 发送[heartbeat_timeout]事件，这个线程一直存在和role无关，follower和candidate忽略heartbeat timeout事件

如果是leader，检查所有follower 上次发送消息的时间，如果超过20ms，发送empty append

## state

参考论文

## 消息处理

### message

vote，vote reply,append,append reply, heartbeat_timeout,append timeout,timeout check,snapshot,snapshot reply

### leader

#### vote

有效：term > me and not vote in the term
接受：set term=request term
     role=follow
     update timeout check
     record vote for
     persist stat
     reply true
拒绝：reply false

#### append

todo

#### timeout check

无

#### snapshot

### follower

#### vote

同leader

### append

参考论文 p4

检查request是否有效 term=>me.term
term<me.term 忽略
term>=me.term me.term=term
更新leader_timeout_check
检查是否接受append entry，对比perv term 和prev index
这里entry可能是空
返回append reply

#### timeout check

修改状态是candidate
修改term+1
save state
发起vote
启动新的timeout check 线程

#### snapshot

### candidate

#### vote

同leader

#### vote reply

有效：reply term=now term
行为：记录reply成功的数量，大于半数认为成功
    role=leader
    persiste stat
    send empty append

#### append

有效性检查
修改role=follower
其他和follower相同

#### timeout check

same as follower

#### snapshot
