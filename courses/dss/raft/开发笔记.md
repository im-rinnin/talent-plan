# 简要说明

## 注意

在发出请求之前需要进行persist stat，如果状态由变化的话

## 逻辑处理架构

raft维护raft的节点相关状态
raft handler 处理所有事件（外部请求，超时等等），修改raft 状态，返回/发出对应请求
raft handler own raft
raft handler 通过一个chan接受外部事件，同时实现对raft状态修改的串行化
事件处理流程是raft handler 的main函数,raft算法基本都通过这个事件触发的处理函数体现

**重要**
事件处理的流程的框架
根据role和event,派发相应的处理流程
处理流程的通用框架
validate event,修改状态，状态pesister,发送消息给其他节点/回复
可以根据这个框架来写单测,即输入事件，role，状态，检查状态变化，发送的消息

## 状态变化checklist

|election 超时|heartbeat timeout|append|append apply|vote|vote apply|

## 单元测试

### 选举

#### candidates

[x]超时开始选举
[x]选举失败，没有达到半数，继续下一轮
[x]选举失败，其他节点成功
[x]选举成功，发送心跳
[x]选举失败，term 大于当前，更新term

#### following and leader

[x] followe/leader 接受选举
[x] followe/leader 拒绝选举 已经投票/term  
[x] followe/leader 拒绝选举 logs不够新

### append

[x]正常append leader,follower
[x]append 截断 follower
[x]失败，term不符合当前
[x]拒绝，prex不符合 leader,follower

[x]leader 超时心跳发送
[x] append client 请求成功

[x]append reply 成功leader 更新commit,match_index,next_index
[x] 只对当前term的entry进行commit，之前term的entry，即使数量达到要求，也不进行commit

## 定时器

## election timeout 定时器

使用一个线程，sleep到[election_timeout_check] 时间点，发送超时事件给main,这个事件包含timeout check 时间点的数值
handler开始后需要初始化这个定时线程
timeout check时间点的设定：接受到外部有效信息（vote,append)后，说明当前有leader或者candidate存活，更新这个时间点，设置为now+rand(150-300ms)
当接收到timeout 事件，检查事件记录的timeout 时间点的数值是否等于当前的timeout check
如果是，说明没有接收到其他节点发来的有效信息，需要进行vote
如果不是，说明不需要vote，启动一个新的定时线程，重复sleep 到timeout check时间点

## leader heartbeat 定时器

heartbeat 时间，论文没找到，[election_timeout] 最小为150，network的delay最多是27,heartbeat使用20吧,这样在[election_timeout]之前可以发送3次

使用一个线程,每隔20ms 发送[heartbeat_timeout]事件，这个线程一直存在和role无关，follower和candidate忽略heartbeat timeout事件

如果是leader，检查所有follower 上次发送消息的时间，如果超过20ms，发送empty append
